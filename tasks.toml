# tasks.toml
# Core project tasks - run with `mise run <task>`

# --- Cargo ---

[build]
description = "Build the project (debug)"
run = "cargo build"

["build:release"]
description = "Build the project (release)"
run = "cargo build --release"

[test]
description = "Run all tests"
run = "cargo test --workspace"

[fmt]
description = "Format code"
run = "cargo fmt"

["fmt:check"]
description = "Check formatting"
run = "cargo fmt --check"

[clippy]
description = "Run clippy linter"
run = "cargo clippy --workspace -- -D warnings"

[verify]
description = "Run all checks (fmt + clippy + test + build)"
run = "cargo fmt --check && cargo clippy --workspace -- -D warnings && cargo test --workspace && cargo build --release"

["snapshot:accept"]
description = "Accept snapshot changes and show diff"
run = "cargo insta accept && git diff"

# --- Provider ---

["test:providers"]
description = "Run provider tests only"
run = "cargo test -p agtrace-providers"

["test:types"]
description = "Run types tests only"
run = "cargo test -p agtrace-types"

# --- Database ---

["db:init"]
description = "Initialize workspace: detect providers, create DB, scan logs"
run = "cargo run --release -- init"

["db:update"]
description = "Scan for new sessions and add to the index"
run = "cargo run --release -- --all-worktrees index update"

["db:rebuild"]
description = "Clear and rebuild the entire index from scratch"
run = "cargo run --release -- --all-worktrees index rebuild"

["db:info"]
description = "Show database location, size, and index statistics"
run = "cargo run --release -- index info"

["db:doctor"]
description = "Scan all log files and report parsing errors"
run = "cargo run --release -- doctor run"

# --- Sessions ---

[sessions]
description = "List recent sessions across worktrees (mise run sessions -- --limit 20)"
run = "cargo run --release -- --all-worktrees sessions"

[session]
description = "Show detailed session analysis (mise run session -- <session-id>)"
run = "cargo run --release -- session show"

# --- Lab ---

["lab:grep"]
description = "Search event payloads (mise run lab:grep -- 'pattern' [--json] [--limit N] [--type ToolCall] [--tool Read])"
run = "cargo run --release -- lab grep"

["lab:stats"]
description = "Show tool usage statistics (mise run lab:stats -- [--limit N] [--provider claude_code])"
run = "cargo run --release -- lab stats"

["lab:export"]
description = "Export session to file (mise run lab:export -- <session-id> [--export-format text] [--strategy clean])"
run = "cargo run --release -- lab export"

# --- Lab: Raw Data Exploration ---

["lab:raw:ls"]
description = "List Claude Code raw log files for current project"
run = """
#!/bin/bash
set -euo pipefail
CWD=$(pwd)
DIR_NAME=$(echo "$CWD" | sed 's|/|-|g; s|\\.|-|g')
LOG_DIR="$HOME/.claude/projects/$DIR_NAME"
if [[ ! -d "$LOG_DIR" ]]; then
  echo "No Claude Code logs found for: $CWD"
  echo "Expected: $LOG_DIR"
  exit 1
fi
echo "ðŸ“ $LOG_DIR"
echo ""
ls -lhtr "$LOG_DIR"/*.jsonl 2>/dev/null | awk '{print $6, $7, $8, $5, $9}' || echo "No .jsonl files found"
"""

["lab:raw:cat"]
description = "View raw JSONL records (mise run lab:raw:cat -- <session-id-prefix|file-path> [lines=50])"
run = """
#!/bin/bash
set -euo pipefail
TARGET="${1:?Usage: mise run lab:raw:cat -- <session-id-prefix|file-path> [lines=50]}"
LINES="${2:-50}"
if [[ -f "$TARGET" ]]; then
  FILE="$TARGET"
else
  CWD=$(pwd)
  DIR_NAME=$(echo "$CWD" | sed 's|/|-|g; s|\\.|-|g')
  LOG_DIR="$HOME/.claude/projects/$DIR_NAME"
  FILE=$(ls "$LOG_DIR"/${TARGET}*.jsonl 2>/dev/null | head -1)
  if [[ -z "$FILE" ]]; then
    echo "No log file found matching: $TARGET"
    echo "Searched in: $LOG_DIR"
    exit 1
  fi
fi
echo "ðŸ“„ $(basename "$FILE")"
echo ""
head -n "$LINES" "$FILE" | jq .
"""

["lab:raw:latest"]
description = "Show raw records from the most recent session (mise run lab:raw:latest -- [lines=30])"
run = """
#!/bin/bash
set -euo pipefail
LINES="${1:-30}"
CWD=$(pwd)
DIR_NAME=$(echo "$CWD" | sed 's|/|-|g; s|\\.|-|g')
LOG_DIR="$HOME/.claude/projects/$DIR_NAME"
FILE=$(ls -t "$LOG_DIR"/*.jsonl 2>/dev/null | head -1)
if [[ -z "$FILE" ]]; then
  echo "No Claude Code logs found in: $LOG_DIR"
  exit 1
fi
echo "ðŸ“„ Latest: $(basename "$FILE")"
echo ""
head -n "$LINES" "$FILE" | jq .
"""

["lab:raw:fields"]
description = "Extract unique JSON field names by record type (schema investigation)"
run = """
#!/bin/bash
set -euo pipefail
TARGET="${1:-}"
CWD=$(pwd)
DIR_NAME=$(echo "$CWD" | sed 's|/|-|g; s|\\.|-|g')
LOG_DIR="$HOME/.claude/projects/$DIR_NAME"
if [[ -n "$TARGET" && -f "$TARGET" ]]; then
  FILE="$TARGET"
elif [[ -n "$TARGET" ]]; then
  FILE=$(ls "$LOG_DIR"/${TARGET}*.jsonl 2>/dev/null | head -1)
else
  FILE=$(ls -t "$LOG_DIR"/*.jsonl 2>/dev/null | head -1)
fi
if [[ -z "$FILE" || ! -f "$FILE" ]]; then
  echo "No log file found. Usage: mise run lab:raw:fields -- [session-id|file-path]"
  exit 1
fi
echo "ðŸ“„ Analyzing: $(basename "$FILE")"
echo ""
cat "$FILE" | jq -r '
  (.type // "unknown") as $type |
  keys | map(select(. != "type")) | sort | join(", ") |
  "\\($type)\\t\\(.)"
' 2>/dev/null | sort -u | awk -F'\\t' '
  BEGIN { prev="" }
  {
    if ($1 != prev) {
      if (prev != "") print ""
      printf "=== %s ===\\n", $1
      prev = $1
    }
    print "  " $2
  }
'
"""

["lab:raw:diff"]
description = "Compare normalized AgentEvent vs raw data for a pattern (mise run lab:raw:diff -- <pattern> [limit=1])"
run = """
#!/bin/bash
set -euo pipefail
PATTERN="${1:?Usage: mise run lab:raw:diff -- <pattern> [limit=1]}"
LIMIT="${2:-1}"
cargo run --release -- lab grep "$PATTERN" --raw --limit "$LIMIT"
"""

# --- Convenience ---

[watch]
description = "Monitor live agent sessions in real-time TUI"
run = "cargo run --release -- watch"

[projects]
description = "List all indexed projects"
run = "cargo run --release -- project list"

# --- Release ---
#
# See `.claude/commands/release.md` for full release procedure.

["release:dry-run"]
description = "Dry-run release (mise run release:dry-run -- patch|minor|major)"
run = "cargo release --workspace --no-verify"

["release:execute"]
description = "Execute release (mise run release:execute -- patch|minor|major)"
run = "cargo release --workspace --execute"

["release:changelog"]
description = "Generate CHANGELOG for next release (mise run release:changelog -- patch|minor|major)"
run = """
#!/bin/bash
set -euo pipefail
RELEASE_LEVEL="${1:?Usage: mise run release:changelog -- patch|minor|major}"
LAST_TAG=$(git describe --tags --abbrev=0)
CURRENT_VERSION=${LAST_TAG#v}
IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
case "$RELEASE_LEVEL" in
  major) NEXT_VERSION="$((major + 1)).0.0" ;;
  minor) NEXT_VERSION="${major}.$((minor + 1)).0" ;;
  patch) NEXT_VERSION="${major}.${minor}.$((patch + 1))" ;;
  *) echo "Invalid release level: $RELEASE_LEVEL" >&2; exit 1 ;;
esac
echo "Current: $CURRENT_VERSION -> Next: $NEXT_VERSION"
git cliff ${LAST_TAG}..HEAD --unreleased --tag v${NEXT_VERSION} --prepend CHANGELOG.md
echo "CHANGELOG.md updated. Review and commit."
"""

# --- Git Workflow (using gw CLI) ---
#
# Worktree-aware git workflow.
# Do not use `git checkout main` â€” use `mise run git:home` instead.
#
# gw: cargo install git-workflow
# https://crates.io/crates/git-workflow

["git:home"]
description = "Switch to home branch and sync with origin/main"
run = "gw home"

["git:new"]
description = "Create new branch from origin/main (mise run git:new -- feature/name)"
run = "gw new"

["git:cleanup"]
description = "Delete merged branch and return to home (mise run git:cleanup -- [branch])"
run = "gw cleanup"

["git:status"]
description = "Show current git workflow state"
run = "gw status"

["git:pause"]
description = "Pause work: WIP commit + return to home (mise run git:pause -- [message])"
run = "gw pause"

["git:abandon"]
description = "Abandon changes and return to home"
run = "gw abandon"

["git:undo"]
description = "Undo last commit (soft reset HEAD~1)"
run = "gw undo"

["git:sync"]
description = "Sync current branch after base PR merge (update base to main, rebase, push)"
run = "gw sync"

["git:open-pr"]
description = "CI wait -> open in browser -> watch merge -> cleanup (mise run git:open-pr -- <pr#> [--no-wait])"
run = """
#!/bin/bash
set -euo pipefail
WAIT_CI=true
ARG=""
for arg in "$@"; do
  case "$arg" in
    --no-wait) WAIT_CI=false ;;
    *) ARG="$arg" ;;
  esac
done
if [[ -z "$ARG" ]]; then
  echo "Usage: mise run git:open-pr -- <pr-number-or-url> [--no-wait]" >&2
  exit 1
fi
if [[ "$ARG" =~ ^[0-9]+$ ]]; then
  PR_NUMBER="$ARG"
  URL=$(gh pr view "$PR_NUMBER" --json url --jq '.url')
else
  URL="$ARG"
  PR_NUMBER=$(echo "$URL" | grep -oE '[0-9]+$' || "")
fi

# Phase 1: Wait for CI
if [[ "$WAIT_CI" == true && -n "$PR_NUMBER" ]]; then
  echo "[git:open-pr] Phase 1/3: Waiting for CI checks on PR #${PR_NUMBER}..."
  gh pr checks "$PR_NUMBER" --watch || echo "[git:open-pr] CI checks failed or timed out, opening anyway"
fi

# Phase 2: Open in browser
# Use OPEN_URL_CMD if set (e.g. in dotfiles), otherwise default browser
echo "[git:open-pr] Phase 2/3: Opening PR in browser..."
if [[ -n "${OPEN_URL_CMD:-}" ]]; then
  $OPEN_URL_CMD "$URL"
else
  gh pr view "$PR_NUMBER" --web
fi

# Phase 3: Watch for merge
if [[ -n "$PR_NUMBER" ]]; then
  INTERVAL=30
  echo "[git:open-pr] Phase 3/3: Watching PR #${PR_NUMBER} for merge (interval: ${INTERVAL}s)..."
  while true; do
    STATE=$(gh pr view "$PR_NUMBER" --json state --jq '.state' 2>/dev/null || echo "ERROR")
    case "$STATE" in
      MERGED)
        echo ""
        echo "========================================"
        echo "[git:open-pr] PR #${PR_NUMBER} MERGED!"
        echo "========================================"
        if command -v osascript &>/dev/null; then
          osascript -e 'display notification "PR #'"${PR_NUMBER}"' merged. Running cleanup..." with title "Git Workflow" sound name "Glass"'
        fi
        echo "[git:open-pr] Running: mise run git:cleanup"
        mise run git:cleanup
        exit 0
        ;;
      CLOSED)
        echo "[git:open-pr] PR #${PR_NUMBER} was closed without merging"
        exit 0
        ;;
      OPEN)
        sleep "$INTERVAL"
        ;;
      ERROR)
        echo "[git:open-pr] Failed to fetch PR status, retrying..."
        sleep "$INTERVAL"
        ;;
    esac
  done
fi
"""
